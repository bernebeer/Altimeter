// Laad libraries
#include <Average.h>
#include <EEPROM.h>
#include <SFE_BMP180.h>
#include <Wire.h>
#include "U8glib.h"

// Initialiseer BMP180 en SSD1306
SFE_BMP180 pressure;
U8GLIB_SSD1306_128X64 u8g(5, 6);

// Defines
#define btn1Pin 4
#define btn2Pin 2
#define btn3Pin A1
#define buzzerPin 3
#define voltSensePin A7
#define chargeStatPinIn A2
#define chargeStatPinOut A3

// Global variables
char status;
double T,P,p0,a;
int voltSenseValues[31];
int capacityMappedPercentage;
int capacityMappedSegment;
float batteryVoltage;
unsigned long adcReadingVoltSensePin;
char *menu_strings[] = {"Hoogte", "void", "Temperatuur", "void", "Druk in millibar", "void", "Druk per uur", "void", "Calibratiehoogte", "Hoogte instellen"};
float dataMiddleLineOne;
String stringBottom;
int menuItem = 0;
uint8_t chargeStatus;
int buttonDelay = 150; // Tijd in ms nadat button opnieuw polled
long calPressure = 10001234;
long calAltitude = 100;
int address = 0;
int histData[10] = {962,962,962,962,962,962,962,962,962,962}; // Range is 962 - 1020 = 60millibar, 960 geeft error, 0 delen 2 is error
int newPressureReading;
long previousMillis = 0;
long previousMillis2 = 0;
long interval = 3600000;
boolean demoMode = false;
char diffValue[10];
boolean altModeTemp = false;

// Bitmaps PROGMEM
const uint8_t chargeIcon[] PROGMEM = {0x24, 0x24, 0xFF, 0x00, 0xFF, 0x7E, 0x7E, 0x3C};  // Bitmap laadicon, plug
const uint8_t doneIcon[] PROGMEM = {0x01, 0x03, 0x07, 0x8F, 0xDE, 0xFC, 0x78, 0x30};    // Bitmap charge complete icon, onnodig i.v.m. blacktopped MCP73832 i.p.v MCP73831, checkmark
const uint8_t splashIcon[] PROGMEM = {                                                  // Bitmap splashscreen, bergen
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00,
0x00, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
0x00, 0x00, 0x00, 0xFF, 0xE0, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xF0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,
0x00, 0x00, 0x03, 0xFF, 0xF8, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x07, 0xFF, 0xFC, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0xFE, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,
0x00, 0x00, 0x1F, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0,
0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8,
0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

void setup(void) {
  
  // Teken niks, clear screen, anders noise in startup, andere manier?
  u8g.firstPage();  
  do {
  } 
  while( u8g.nextPage() );
  
  // Roteer scherm en teken splashscreen
  u8g.setRot180();  
  u8g.firstPage();  
  do {
    drawSetup();
  } 
  while( u8g.nextPage() );
  
  // pinModes zetten, CS OLED, Arduino pin 5, naar OUTPUT zetten maakt niks uit v.w.b. prestatie...
  pinMode(btn1Pin, INPUT_PULLUP);
  pinMode(btn2Pin, INPUT_PULLUP);
  pinMode(btn3Pin, INPUT_PULLUP);
  pinMode(chargeStatPinOut, OUTPUT);
  pinMode(chargeStatPinIn, INPUT);
  
  // btn1 induwen tijdens setup activeert Demomode
  if (digitalRead(btn1Pin) == LOW) {
     demoMode = true;
  }
  
  // Initialise BMP180
  if (pressure.begin()) {
    // Goed voor elkaar
  }    
  else {
    // while(1); // Error...
  }
  
  // EEPROM lees calibration waarden calPressure, calAltitude
  calPressure = EEPROMReadlong(address);  
  address += 4; // Advance 4 eeprom-addresses because 4 bytes long
  calAltitude = EEPROMReadlong(address);  
  delay(2000); // Wacht even tot loop i.v.m. splashscreen
  
}

// Pictureloop splashscreen u8glib picture loop
void drawSetup(void) {  
  u8g.setDefaultForegroundColor();
  u8g.drawBitmapP( 0, 0, 16, 64, splashIcon);  
}


void loop(void) {  
  
  // Lees BMP180 I2C data
  status = pressure.startTemperature();
  if (status != 0) {
    // Wait for the measurement to complete:
    delay(status);
    status = pressure.getTemperature(T);
    if (status != 0) {
      status = pressure.startPressure(3);
      if (status != 0) {
        // Wait for the measurement to complete:
        delay(status);
        status = pressure.getPressure(P,T);
        if (status != 0) {
          a = pressure.altitude(P,(calPressure / 10000.0000));  // 'a' wordt berekend in functie adhv huidige druk vs. baseline druk, Sparkfun library
                                                                // calPressure = baseline druk
                                                                // calPressure (gemeten in millibars) wordt in setup geladen uit EEPROM / geset in loop als long 4 byte 
                                                                // Om de long weer kloppend te maken deel je deze door 10000.0000 (calPressure = float)
                                                                // Return uit functie (a) is verschil in meters tussen baseline (calPressure / 10000.0000) en gemeten druk (P)
                                                                // Later in code, current altitude wordt verkregen door in EEPROM opgeslagen baseline hoogte (calAlititude) op te tellen bij return uit functie
                                                                // VB. current altitude = a + calAltitude --> Zeg je baseline height = 2m (Soest) en resultaat uit functie, a = -20m
                                                                //     current altitude = -20 + 2 = 18m
        }
      }
    }
  }

  // Lees histData 
  // Pas array aan, anders geen data in grafiek bij laden  
  histData[9] = P;  
  // Periodiek (interval) histData array 1 positie naar links shiften
  unsigned long currentMillis = millis();
  if(currentMillis - previousMillis > interval) {    
    previousMillis = currentMillis;
    newPressureReading = P;    
    for (int i = 0; i < 9; i++) {
      histData[i] = histData[i + 1];
    }    
  }

  // Lees voltage batterij en map naar segmenten - // Divider 10k 36k, 0.783 reduction factor | 1.278 multiplier factor, 1024 steps van 0 - 3300mV, ergo 3.223mV / step  
  adcReadingVoltSensePin = rollingAverage(voltSenseValues, 31, analogRead(voltSensePin));  
  if (adcReadingVoltSensePin > (analogRead(voltSensePin) - 25)) { 
    batteryVoltage = adcReadingVoltSensePin * 3.223 * 1.278; // multiply with mV and multiply with inverse resistor divider reduction factor
  }
  else {
    batteryVoltage = analogRead(voltSensePin) * 3.223 * 1.278; // Zorg ervoor dat er iig een reading is voor de bar display, anders loopt de rolling average te langzaam op.
  }  
  capacityMappedPercentage = map(batteryVoltage, 3300, 4175, 0, 100);
  if (capacityMappedPercentage > 100) { // Make sure it doesnt map over 100%
    capacityMappedPercentage = 100; 
  }
  capacityMappedSegment = capacityMappedPercentage / 20;
  
  // Stel menuItem in
  // Check menuitem is even (skip submenuitem)
  if (menuItem % 2 == 0) {
    if (digitalRead(btn1Pin) == LOW) {
      menuItem = menuItem - 2;
      if (menuItem < 0) {
        menuItem = 8;
      }
      delay(buttonDelay);  
    }
    if (digitalRead(btn2Pin) == LOW) {
      menuItem = menuItem + 2;
      if (menuItem > 8) {
        menuItem = 0; 
      }
      delay(buttonDelay);
    }
    if (digitalRead(btn3Pin) == LOW) {
      menuItem++;
      delay(buttonDelay);
    } 
  }
  
  // Demomode
  if (demoMode == true) {
    unsigned long currentMillis2 = millis();
    if(currentMillis2 - previousMillis2 > 5000) {
      menuItem = menuItem + 2;
      if (menuItem > 8) {
        menuItem = 0;
      }
      if (menuItem == 2) { // Toggle celsius of fahrenheit per cyclus, i.e. per keer dat menuItem 2 actief is
        altModeTemp = !altModeTemp;
      }
      previousMillis2 = currentMillis2;
    }    
  }
  
  // Cases voor menusysteem
  switch (menuItem) {
    
    case 0: // alt
      dataMiddleLineOne = a + calAltitude;
      stringBottom = menu_strings[menuItem];
      break;
      
    case 1:
      menuItem = 0;
      break;
      
    case 2: // temp
      if (altModeTemp == true) {
        dataMiddleLineOne = T * 9/5 + 32;
      }
      else {
        dataMiddleLineOne = T; 
      }
      stringBottom = menu_strings[menuItem];
      break;
      
    case 3:
      altModeTemp = !altModeTemp;
      menuItem = 2;
      break;
      
    case 4: // P
      dataMiddleLineOne = P;
      stringBottom = menu_strings[menuItem];
      break;
      
    case 5:
      menuItem = 4;
      break;      
      
    case 6:
      //dataMiddleLineOne = 0;
      stringBottom = menu_strings[menuItem];
      break;
     
    case 7:
      menuItem = 6;
      break; 
      
    case 8: // calibration
      dataMiddleLineOne = calAltitude;
      stringBottom = menu_strings[menuItem];
      break;
    
    case 9:
      dataMiddleLineOne = calAltitude;
      if (digitalRead(btn1Pin) == LOW) {
        calAltitude = calAltitude + 100;
        if (calAltitude > 4000) {
          calAltitude = 0;
        }
      }
      if (digitalRead(btn2Pin) == LOW) {
        calAltitude = calAltitude + 1;
        if (calAltitude > 4000) {
          calAltitude = 0;
        }
      }
      if (digitalRead(btn3Pin) == LOW) {
        calPressure = P * 10000L;
        EEPROMWritelong(0, calPressure);
        EEPROMWritelong(4, calAltitude);
        delay(1000);
        menuItem = 0;
      }
      stringBottom = menu_strings[menuItem];
      break;
    
  }
  
  /* Detect charge status
  boolean firstReading = digitalRead(chargeStatPinIn);
  digitalWrite(chargeStatPinOut, HIGH);
  boolean secondReading = digitalRead(chargeStatPinIn);
  if (firstReading == true && secondReading == false) { // Getest: true, true; false, true (in shutdown actief); true, false; --> Blacktopped MCP73832, dus geen tri-state status pin?
    chargeStatus = 0; // Charge Complete - Standby, STAT pin MCP73831 HIGH
  }
  else if (firstReading == false && secondReading == false) { 
    chargeStatus = 1; // Charging, STAT Pin MCP73831 LOW
  }
  else {
    chargeStatus = 2; // Shutdown, STAT Pin MCP73831 Hi-Z
  }
  digitalWrite(chargeStatPinOut, LOW);  
  */
  
  boolean firstReading = digitalRead(chargeStatPinIn);
  digitalWrite(chargeStatPinOut, HIGH);
  boolean secondReading = digitalRead(chargeStatPinIn);
 
  if (firstReading == false && secondReading == false) { 
    chargeStatus = 1; // Charging, STAT Pin MCP73831 LOW
  }
  else if (firstReading == false && secondReading == true) {
    chargeStatus = 2; // Shutdown, STAT Pin MCP73831 Hi-Z
  }
  else {
    chargeStatus = 0; // Charge Complete - Standby, STAT pin MCP73831 HIGH
  }
  digitalWrite(chargeStatPinOut, LOW);  
  
  // Main u8glib picture loop
  u8g.firstPage();  
  do {
    draw();
  } while( u8g.nextPage() );
  
  // rebuild the picture after some delay
  // delay(50);

}

void draw(void) {
  
  // Top elementen tekenen
  u8g.setFont(u8g_font_7x13B);
  u8g.setDefaultForegroundColor();
  u8g.drawBox(0,0,128,16);
  // Batterij box
  u8g.setDefaultBackgroundColor();
  u8g.drawBox(2,2,42,12);
  // Batterij tip
  u8g.drawBox(44,6,2,4);
  // Batterij segmenten
  u8g.setDefaultForegroundColor();
  for(int i = 0; i < capacityMappedSegment; i++) {
    u8g.drawBox(i * 8 + 4, 4, 6, 8);
  }
  
  if (demoMode == true) {
    u8g.setDefaultBackgroundColor();
    u8g.setPrintPos(50, 13);
    u8g.print("DEMOMODE");
  }
  
  // Charge status weergave - Debug info
  //u8g.setDefaultBackgroundColor();
  //u8g.setPrintPos(87, 13);
  //u8g.print("Debug");
  
  if (chargeStatus == 1) {
    u8g.setDefaultBackgroundColor();
    u8g.drawBox(114,2,12,12);
    u8g.setDefaultForegroundColor();
    u8g.drawBitmapP( 116, 4, 1, 8, chargeIcon);
  }
  if (chargeStatus == 0) {
    u8g.setDefaultBackgroundColor();
    u8g.drawBox(114,2,12,12);
    u8g.setDefaultForegroundColor();
    u8g.drawBitmapP( 116, 4, 1, 8, doneIcon);
  }
  
  // Middelste elementen tekenen
  u8g.setDefaultForegroundColor();
  u8g.setScale2x2();
  u8g.setPrintPos(0, 21);
  
  if (menuItem == 0 || menuItem == 8) { // Display hoogte of calibratiehooogte
    u8g.print(dataMiddleLineOne, 0);
    u8g.undoScale();  
    u8g.setPrintPos(93, 42);
    u8g.print("METER");
  }
  else if (menuItem == 2) { // Display temperatuur in Celsius of Fahrenheit 
    u8g.print(dataMiddleLineOne, 1);
    u8g.undoScale(); 
    u8g.setPrintPos(79, 42);
    if (altModeTemp == true) {
      u8g.print("FAHRENH.");
    }
    else {
      u8g.print("CELSIUS");
    }
  }
  else if (menuItem == 4) { // Display druk
    u8g.print(dataMiddleLineOne, 4); 
    u8g.undoScale(); 
  }
  else if (menuItem == 6) { // Display grafiek historische druk
    u8g.undoScale();    
    for (int i = 0; i < 10; i++) {      
      u8g.setDefaultForegroundColor();
      unsigned int yPos = 48 - ((histData[i] - 960) / 2); // Set starting point top left corner box, y position of 48 - height of box
      u8g.drawBox( i * 13, yPos, 11, (histData[i] - 960) / 2 ); 
    }
  }  
  else if (menuItem == 9) { // Display hoogte instellen
    u8g.print(dataMiddleLineOne, 0);
    u8g.undoScale();  
    u8g.setPrintPos(93, 42);
    
    if (millis() % 1000 > 500) {
      u8g.setDefaultForegroundColor();
    }
    else {
      u8g.setDefaultBackgroundColor(); 
    }
    u8g.print("METER");
  }    
  else {
    u8g.print(dataMiddleLineOne, 2);
    u8g.undoScale();    
  }
  
  // Lijn onderaan tekenen
  u8g.setDefaultForegroundColor();
  u8g.drawHLine(0, 50, 128);
  
  // Onderste elementen tekenen
  u8g.setPrintPos(0, 64);
  u8g.print(stringBottom);
  
}

void EEPROMWritelong(int address, long value) {
  
  byte four = (value & 0xFF);
  byte three = ((value >> 8) & 0xFF);
  byte two = ((value >> 16) & 0xFF);
  byte one = ((value >> 24) & 0xFF);
  
  EEPROM.write(address, four);
  EEPROM.write(address + 1, three);
  EEPROM.write(address + 2, two);
  EEPROM.write(address + 3, one);
  
}

long EEPROMReadlong(long address) {
  
  long four = EEPROM.read(address);
  long three = EEPROM.read(address + 1);
  long two = EEPROM.read(address + 2);
  long one = EEPROM.read(address + 3);
  
  return ((four << 0) & 0xFF) + ((three << 8) & 0xFFFF) + ((two << 16) & 0xFFFFFF) + ((one << 24) & 0xFFFFFFFF);
  
}
